\documentclass{llncs}

\usepackage{amssymb}
\usepackage{changepage}
\usepackage{tabu}
\usepackage{bussproofs}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=newest}
\usepackage{filecontents}
\usepackage{siunitx}
\usepackage{booktabs} 
\usepackage{pgfplotstable}
\usepackage{color}
\graphicspath{ {images/} }

\newcommand{\textred}[1]{\textrm{\textcolor{red}{#1}}}
\newcommand{\textgreen}[1]{\textrm{\textcolor{green}{#1}}}

\newenvironment{myindent}{\begin{adjustwidth}{2ex}{}}{\end{adjustwidth}}
%\usepackage{caption}
%\usepackage{eeesubcaption}
\title{Modular Formalisation and Verification of \\STV Algorithms}
\author{Milad~K.~Ghale\and
        Rajeev~Gor\'e\and
        Dirk~Pattinson\and
        Mukesh Tiwari}
\institute{The Australian National University}
\begin{document}
\maketitle
\pagestyle{plain}
\thispagestyle{empty}
\begin{abstract}
We introduce a formal, modular framework that captures a large number of
different instances of the Single Transferable Vote (STV) counting
scheme in a uniform way. The framework requires that each instance
defines the precise mechanism of counting and transferring ballots,
electing and eliminating candidates. From formal proofs of basic
sanity conditions for each mechanism inside the Coq theorem prover, we then synthesise
code that implements the given scheme in a provably correct way and
produces a universally verifiable certificate of the count. We have
applied this to various variations of STV, including several  used in Australian
parliamentary elections and demonstrated the feasibility of our
approach by means of real-world case studies.
\end{abstract}

\section{Introduction}
 Single Transferable Vote (STV) is a family of 
 vote counting schemes where voters express their 
 preferences for competing candidates by ranking them on a ballot
 paper. STV is used
%directly or indirectly, 
in many 
 countries including Ireland, Malta, India, Nepal, New Zealand and
 Australia. It is also used to elect moderators in the
 StackExchange discussion forum~\cite{StackExchange:2018:ME} and the
 board of trustees of the John Muir trust~\cite{Trust:2018:AT}. 

 To count an election according to STV, one usually computes a quota
 dependent on the number of ballots cast (often the Droop quota
 \cite{Droop:1881:MER}) and then proceeds as follows:
 \begin{enumerate}
 \item Count all first preferences on ballot papers;
 \item Elect all candidates whose first preferences meet or exceed the
 quota;
 \item Transfer surplus votes, i.e. votes of elected candidates beyond and
 over the quota are transferred to the next preference;
 \item If all transfers are concluded and there are still vacant
 seats, eliminate the least preferred candidate, and transfer his/her  votes
 to the next preference.
 \end{enumerate}

\noindent
While the scheme appears simple and perspicuous, the above
description hides lots of detail, in particular concerning precisely
which ballots are to be transferred to the next preference.
Indeed, many jurisdictions differ in precisely that detail and
stipulate a different subset of ballots be transferred, typically at
a fractional weight (the so-called \emph{transfer value}). 
For example, in the Australian Capital Territory (ACT) lower house
STV election scheme, only the 
\emph{last parcel} of an elected candidate (the ballots attributed
to the candidate at the last
count)  of an elected candidate is transferred. In
contrast, the STV variant used in the upper house of the
Australian state of Victoria transfers \emph{all} ballots (at a
reduced transfer value). Similar differences also exist for the
transfer of votes when a candidate is being eliminated. 

On the other hand, all variants of STV share a large set of
similarities. All use the same mechanism (transfer, count, elect,
eliminate) to progress the count
and, 
for example, all 
%protocols  state that scrutiny shall 
cease counting once all
vacancies are filled. 
%
In this paper, we abstract the commonalities of all different
flavours of STV into a set of minimal requirements that we
(consequently) call 
\emph{minimal} STV. It consists of:
\begin{itemize}
\item the data (structure) that captures all states of the count
\item the requirements that building blocks (transfer, count,
\dots) must obey.
% \item the requirements that count, elect, eliminate, transfer, and
% three others, 
% %have to 
% must obey
\end{itemize}
\noindent
In particular, we formally understand each single
discrete state of counting as a mathematical object
which comprises some data. Based on the kind of data that such an
object encapsulates, we separate them into three sets: initial
states (all ballots uncounted), final states
(election winners are declared) and intermediate states. The latter
carry seven pieces of information: 
the list of remaining uncounted ballots which must be dealt with;
the current tally of each candidate; 
the pile of ballots counted in each candidate's favour;
the list of elected candidates whose votes await transfer;
the list of eliminated candidates whose votes await transfer;
the list of elected candidates; 
and the list of continuing candidates. 
Basically, they record the current state of the tally computation.

We realise transitions between states, corresponding to acts of counting,
eliminating, transferring, electing, and declaring winners,
% committed by tally officers, 
as formal rules that relate a pre-state and a
post-state. These rules are what varies between different flavours
of STV,
so
%As a consequence, 
minimal STV does not define them.
%rules, but
Instead, it
%rather 
postulates minimal \emph{conditions} that each rule must
satisfy. An \emph{instance} of STV is then given by:
\begin{enumerate}
\item \emph{definitions} of the rules for counting, electing,
eliminating, and transferring;
\item formal \emph{proofs} that the rules satisfy the respective
conditions.
\end{enumerate}

\noindent
We sometimes refer, somewhat informally, to the conditions the various rules must
satisfy as \emph{sanity checks}. They are the
formal counterparts of the legislation that informs counting officers
which action to perform, when. 
Each sanity check consists of two parts: 
the \emph{applicability condition}
specifies under what conditions the rule can be applied while
the \emph{progress condition} specifies the effect of the
rule on the state of the count.
For example, the count rule is applicable 
if there are uncounted ballots and reduces
the number of uncounted ballots.

We establish
three  main properties of this generic version of STV. The first
is that each application of any of the generic transitions
of STV 
%which satisfies its sanity check, 
reduces a complexity measure. The second is that at any
non-final state of the count, at least one of the generic
transitions is applicable because it satisfies its sanity
check requirements. The third is that the overall 
minimal STV algorithm terminates. 

All this is carried out inside the Coq theorem prover
\cite{Bertot:2004:ITP}.  Using Coq's extraction mechanism
\cite{Letouzey:2003:NEC} we can then automatically synthesise a
(provably correct) program for STV counting from the termination
proof.  
By construction, the executables are certifying programs which
produce an visualised trace of computation upon each execution. The
correctness of the certificate can be checked by anyone with minimal
technical knowledge, independent of the way it was obtained. 
That is to say, we provably implement the counted-as-cast
aspect ~\cite{DBLP:journals/iacr/CortierGKMT16} of universal
verifiability. Finally, our experimental tests with real
elections demonstrate feasibility of our approach for  real world
applications. Compared with other formalisations of STV, where
even small changes in the details of a single rule requires adapting
a global correctness proof, the outstanding features of our work
is \emph{modularity}, since sanity checks are local to each
rule, and \emph{abstraction}, since the general correctness proof is based
on the local conditions for each rule. It is precisely this
simplicity that allows us to capture a large number of variations of STV,
including several used in Australian parliamentary elections.
 

% As it stands in correspondence with the actual computation carried
% out by the executable, correctness of the certificate ensures
% flawlessness of the executable. 




\section{The Generic STV Machine}       
%There are numerous elections which use STV for their tallying
%method. Despite the apparent differences observable in the
%particular version of STV which is invoked, there are fundamental
%data and algorithmic structure common among most of them. By
%abstracting these underlying features away, we obtain an abstract
%data structure and minimal constraints which form a generic STV. We
%prove some mathematical properties, such as termination, about the
%generic version.  
%

We begin by describing the components of minimal STV before
discussing their implementation in the Coq theorem prover, together
with examples. 

%Moreover, to make our theoretical approach more sensible, we choose a particular STV algorithm which is used as the counting scheme in the ATC state of Australia for lower house elections. We refer to it throughout to make the discussion concrete to the reader.

%\subsection{The Lower House Australian Capital Territory STV}
%The ACT government of Australia employs a version of STV for electing the lower house representatives\cite{}. The protocol's clauses are specified as follows.
%\begin{description}
%\item[Step 1.] Count the first preference votes for each candidate.
%\item[Step 2.] Calculate the quota : 
%\begin{center}
%(total number of valid votes / (number of seats + 1)) + 1.
%\end{center}
%\item[Step 3.] Any candidate with votes equal to or greater than the quota is declared elected.
%\begin{itemize}
%\item If all vacancies have been filled, the election is completed.
%\item If all vacancies have not been filled, does any candidate have more votes than the quota?
%\begin{enumerate}
%\item If yes then go to step 4.
%\item If no then go to step 5.
%\end{enumerate}
%\end{itemize}
%\item[Step 4.] Distribute the successful candidate's surplus votes to continuing candidates according to the further preferences shown on the ballot papers by those voters.  Calculate each continuing candidate's new total votes, then go back to step 3.
%\item [Step 5.] If there are more continuing candidates than there are vacancies remaining unfilled, exclude the candidate with the fewest votes and distribute this candidate's votes to continuing candidates according to the further preferences shown by those voters. Calculate each continuing candidate's new total votes then go back to step 3.\\ Or, if the number of continuing candidates is equal to the number of vacancies remaining, all of those candidates are declared elected and the election is completed.
%\end{description} 
%In a separate section, the protocol further elaborates on details of some steps such vote transfer:
%\begin{description}
%\item[details of transferring surplus votes.] 
%The value of the surplus votes gained by an elected candidate is passed on to other candidates according to the preferences indicated on ballot papers by the voters. If a candidate has received more than a quota of first preference votes, all the ballot papers received by the candidate are distributed at a reduced value called a fractional transfer value. If a candidate has received more votes than the quota following a transfer of votes from another elected candidate or from an excluded candidate, only that \lq\lq last parcel" of ballot papers that the candidate received are distributed to continuing candidates at a fractional transfer value.\\

%After the surplus votes from an elected candidate have been distributed, the total number of votes which each candidate has received is recalculated. Any further candidates that have votes equal to or greater than the quota are elected. Provided vacancies remain to be filled, the surplus votes of any newly elected candidate are now also distributed one by one.
%\end{description}
\subsection{The Machine States and Transitions}

The best way to think of minimal STV and its instances is in terms
of an abstract machine. The states can be thought of
as snapshots of the hand counting procedure, where there is e.g. a
current tally, and a set of uncounted ballots at every stage.
Tallying is then formalised as transition between these states. 

There are three types of machine states: \emph{initial},
\emph{intermediate}, and \emph{final}. An initial state contains
the list of all \emph{formal} ballots. 
Final states 
%of the machine 
are 
%accepting stages 
where
winners 
%of an election 
are declared. Each intermediate state
consists of seven components: 
\begin{enumerate}
\item A set of uncounted ballots, which must be counted;
\item A tally function computing the number of votes for each candidate;
\item A pile function computing which ballots are assigned to which candidate;
\item A list of already elected candidates whose votes await transfer;
\item A list of the eliminated candidates whose votes need to be dealt with;
\item A list of elected candidates; and
\item A list of continuing candidates.
\end{enumerate}  
%One could think of  the pile and tally functions as abstraction of
%the action performed by tally officers when they respectively assign
%ballots and their values to candidates.


\noindent
We use
$\mathcal{C}$ 
for the set of all candidates participating in an
election and use $c$, $c'$, and $c''$ for individual candidates from 
$\mathcal{C}$. We use 
\textsf{List}($\mathcal{C}$)
for the set of all lists over
$\mathcal{C}$ and
use 
$\mathbb{Q}$ 
for the set of rational numbers.
A ballot is an ordered pair
$(l,q)$ where 
$l\in$ \textsf{List}($\mathcal{C}$) is the preference order and
$q\in\mathbb{Q}$ is the (possibly fractional) value of this ballot.
We write $\mathcal{B} = 
\mathsf{List}(\mathcal{C})\times\mathbb{Q}$ for the set of all
ballots, i.e. preference ordered lists of candidates, together with
a transfer value. 
We use $h$ and $nh$ for lists
of continuing (``\underline{h}opeful'') candidates, and $e$ and $ne$ for lists of
\underline{e}lected candidates.
A \underline{b}ack\underline{l}og is a
pair $(l1,l2)$, the lists of elected and eliminated
candidates, respectively,
%whose votes await transfer, 
%and $l2$ is a list of eliminated candidates,
both of whose votes await transfer. 
We use $bl$, $nbl$ for backlogs, use 
$qu$ for the \underline{qu}ota for being
elected and use $st$ for the number of vacant seats. 
We use $t$, $nt$ for \underline{t}allies and use $p$, $np$ for \underline{p}iles.
The prefix ``$n$'' always stands for ``new'', 
thus $\mathit{ne}$ is the list of elected candidates in the post state,
after an action has been applied.

Suppose that $ba \in \mathsf{List}(\mathcal{B})$, and $bl , h, e, w \in$
\textsf{List}($\mathcal{C}$) are given. Assume $t$ is a
function from $\mathcal{C}$ into $\mathbb{Q}$, and $p$ is a function
from $\mathcal{C}$ into \textsf{List}($\mathcal{B}$). We use
\textsf{initial}($ba$) for the initial state, use 
\textsf{intermediate}($ba, t, p, bl, e, h$)
for an intermediate state, and use
\textsf{final}($w$) for a final one. 
Having established terminology and necessary
representations, we can mathematically define the states of the
generic STV machine.  

\begin{definition}[machine
states]\label{stv:states}
Suppose $ba$ is the initial list of ballots to be counted, and
$l$ is the list of all candidates competing in the election. 
The set $\mathcal{S}$ of states of the generic STV is the union of
all 
possible intermediate and final states that can be constructed from $ba$ and $l$,
together with the initial state \textsf{initial}($ba$).
\end{definition}

We now describe the mechanisms to progress an STV count, such as
electing all candidates that have reached quota. 
These steps, formalised as \emph{rules},  are the essence of each 
particular instance of 
STV, and are one of the two cornerstones of our generic notion of STV: the
other being the properties that rules must satisfy. We stipulate
that each instance of STV needs to implement the following
mechanisms that we formulate as rules relating a pre-state and a
post-state:

\smallskip\noindent\framebox{\parbox{\textwidth}{
\noindent\textbf{start:} to determine the \emph{formal} ballots and
valid initial states; \\
\noindent\textbf{count:} for counting the uncounted ballots;\\
\noindent\textbf{elect:} to elect one or more candidates who have reached or exceeded the quota;\\ 
\noindent\textbf{transfer-elected:} for transferring surplus votes of
already elected candidates; \\
\noindent\textbf{transfer-removed:} to transfer the votes of the eliminated candidate; \\
\noindent\textbf{eliminate:} to eliminate the weakest candidate from
the process; and\\ 
\noindent\textbf{elected win:} to terminate counting by declaring the  already elected candidates as winners; \\
\noindent\textbf{hopeful win:} to terminate counting by declaring the list of elected and continuing candidates as winners.
}}

\smallskip\noindent
For the moment, we treat the above as transition labels only, and
provide semantical meaning in the next section.

\begin{definition}[machine transitions]\label{stv:trans}
The set $\mathcal{T}$ consisting of the labels \textbf{count}, \textbf{elect}, \textbf{transfer-elected}, \textbf{transfer-removed}, \textbf{eliminate}, \textbf{hopeful win}, and \textbf{elected win}, is the set of transition labels of the generic STV.
\end{definition}

\subsection{The Small-step Semantics}
The textual description of STV is usually in terms of clauses that
specify what actions are to be undertaken, under what conditions. In
our formulation, this corresponds to pre- and post-conditions for the
individual counting rules. The pre-condition is an
\emph{applicability constraint}: it specifies under what conditions
a particular rule is applicable. The post-condition is a
\emph{reducibility constraint}: it specifies how applying a rule
progresses the count.  Taken together, they form the \emph{sanity
check} for an individual rule. Technically, applicability
constraints ensure that the count never gets stuck i.e. there is
always one applicable rule, while the reducibility constraint guarantees termination. 

\paragraph{Reducibility.} 
A careful examination of STV protocols shows that each rule
reduces the size of at least one of the following four
objects: the list of continuing candidates; the number of 
ballots in the pile of the most recently eliminated candidate;  the
backlog; and the list of uncounted ballots. Using lexicographic
ordering, this allows us to define a 
a complexity measure on the set of
machine states in such a way that each rule application reduces this
measure. 

\paragraph{Local Rule Applicability.}
Each instance of STV must, and indeed does, impose 
restrictions on when rules can, and must, be applied. Most
depend on the particular instance, but some
are universal. For example, all STV
algorithms require three constraints for the elimination
rule to apply: there must be vacant seats; there must be
no surplus votes awaiting transfer; and no candidate should have
reached or exceeded the quota. We constrain each of the counting
rules in this way to guarantee that at least one rule can always be
applied. 

To formulate the sanity checks for each transition, we 
define a lexicographic ordering on the set 
$\mathbb{N}^5$
%$\mathbb{N}\times\mathbb{N}\times\mathbb{N}\times\mathbb{N}\times\mathbb{N}$ 
and impose it on non-final states of the generic machine.   

\begin{definition} \label{defn:measure}
Let $\{s: \mathcal{S} \mid s\mbox{ not final}\}$ be the set of
non-final machine states. We define a function $\mathsf{Measure}:
\mathcal{S} \to
\mathbb{N}^5$ as follows. We let
\begin{small}\textsf{Measure} (\textsf{initial}($ba$)) =
(1,0,0,0,0)\end{small}. Suppose $bl$ $=$ $(l_{1},l_{2})$, for some
lists $l_{1}$ and $l_{2}$, and for a given candidate $c$,
\textsf{flat} (p c) $=$ $l_{c}$ where for a list of lists $l$,  $\mathsf{flat}$ $l$ is the
concatenation (flattening) of all elements of $l$. Then
\begin{small}
\begin{center}
 \textsf{Measure} (\textsf{state} ($ba,t,p,bl,e,h$)) = (0,
 \textsf{length} $h$, $\sum_{d\in l_{2}}^{}$ \textsf{length}
 $l_{d}$,\textsf{length} $l_{1}$,\textsf{length}  $ba$).
\end{center}
\end{small}
\end{definition}

\noindent
Note that the first component of the co-domain of the measure
function simply reduces measure from the initial state to any
intermediate state, and the third component is the sum of the length
of the ballots cast in favour of eliminated candidates that await
transfer. In the following, we describe
the sanity checks for \textbf{transfer} and \textbf{elect} in detail, 
and leave it to the reader to reconstruct those for the other rules
from the formal Coq development.

\paragraph{Transfer-elected check.} The
\emph{transfer-elected}  rule that decribes the transfer
of surplus votes of an elected candidate 
must satisfy two conditions. The applicability condition
asserts that transfer-elected is applicable to 
any intermediate machine state \textsf{input} of the
form \textsf{state}($[]$,$t$,$p$,$bl$,$e$,$h$), where the list of of
uncounted ballots is empty, if there are vacancies to fill
(\textsf{length}($e$) $< st$), there are surpluses awaiting transfer,
($bl \neq []$), and no continuing candidate has reached or
exceeded the quota. Under these conditions, we stipulate the
existence of a post-state 
\textsf{output} which is reachable from \textsf{input} via a
transition labelled \emph{transfer-elected}. 
The reducibility condition requires that any application of
\emph{transfer-elected} reduces the length of the backlog
$\mathit{bl}$ while elected and continuing candidates remain
unchanged.  Mathematically, this takes the following form:

%\begin{itemize} 
%\item the input of $R$ be an intermediate state where there is no ballot left to count, i.e. $ba = []$, 
%\item the output to be an intermediate state as well, 
%\item any application of $R$ reduces  the length of the backlog. 
%\item the list of uncounted ballots, the pile and the backlog are updated. However, the lists of elected and continuing candidates remain the same as before.
% \end{itemize} 
\begin{definition}[transfer-elected sanity check]\label{trans:check}
A rule $R \subseteq \mathcal{S} \times \mathcal{S}$ satisfies the
\emph{transfer-elected sanity check}  if and only if the following
hold:
\begin{description}
\item[\it applicability:] for any state 
$\mathsf{input} = \mathsf{state}([],t,p,bl,e,h)$ that satisfies 
\textsf{length}($e$) $< st$  (there are still seats to fill), $bl
\neq []$ (there are votes to be transferred) and 
$\forall c.$ $(c \in h \rightarrow (t$ $c$ $< qu))$  (no continuing candidate
has reached the quota), there exists a post-state 
\textsf{output} such that \textsf{input} $R$ \textsf{output}.

\item[\it reducibility:] for any machine states \textsf{input} and
\textsf{output}, if 
$\mathsf{input} ~R~ \mathsf{output}$ then
$\mathsf{input}$ is of the form 
% \textsf{input} $=$
\textsf{state}($[]$,$t$,$p$,$bl$,$e$,$h$), $\mathsf{output}$ is of
the form 
%\textsf{output} $=$
\textsf{state}($nba$,$t$,$np$,$nbl$,$e$,$h$) and \textsf{length}($nbl$)
$<$ \textsf{length}($bl$) (i.e. the backlog is reduced). 
\end{description}
\end{definition}

\noindent
The following is immediate from the definition of measure
(Definition \ref{defn:measure}):
\begin{theorem}\label{trans:red}
If transition label $R$ obeys the reducability
condition of Definition~\ref{trans:check},
\textsf{input} $\in\mathcal{S}$, 
\textsf{output} $\in\mathcal{S}$ and \textsf{input}
$R$ \textsf{output},
then the \textsf{output} complexity 
$\mathsf{Measure}(\mathsf{output})$
%of \textsf{output} 
is lexicographically smaller than
the \textsf{input} complexity
$\mathsf{Measure}(\mathsf{input})$.
%of \textsf{input}.
% Then the complexity of \textsf{output} is less
% than the \textsf{input}, i.e. $\mathsf{Measure}(\mathsf{input})$ is
% lexicographically smaller than $\mathsf{Measure}(\mathsf{output})$
\end{theorem}

\paragraph{Elect check.} The action of electing a candidate, also
formalised as a rule in our framework, is subject to the following
constraints: in the pre-state $\mathsf{input} = $
\textsf{state}($[]$,$t$,$p$,$bl$,$e$,$h$), 
where the list of uncounted ballots is empty,
some
continuing candidate must have reached quota, and there must be
a vacant seat.
%an unfilled vacancy. 
If so, there must exist a
post-state $\mathsf{output}$ where the set of continuing candidates
is smaller, there are still no uncounted ballots, and the piles and
backlog for candidates may be updated. 
%continuing candidateif there exist a
%continuing candidate $c$ which has reached or exceeded the  quota
%and if adding $c$ to the list of vacancies does not cause electing
%more than the number of empty seats, then there is a new machine
%state \textsf{output} which we can move to by $R$. Second, the input
%and output of $R$ must comply with the following constraints :
%\begin{itemize} \item the input must an intermediate machine state
%where there is no uncounted ballot left \item length of the update
%list of continuing candidates $nh$ is shorter than $h$ \item the
%length of the updated list of elected candidates is shorter than $e$
%\item the output is another intermediate state where there are no
%ballots to count \item the pile function is updated to $np$, list of
%the backlog, continuing and elected candidates are updated to $nbl$,
%$nh$, and $ne$, respectively.  \end{itemize}   
%
Mathematically, this takes the following form:
\begin{definition}[elect sanity check]\label{elect:check}
A rule $R \subseteq \mathcal{S} \times \mathcal{S}$ satisfies the
\emph{elect sanity check} if and only if the following two
conditions hold:
\begin{description}
\item[\it applicability:]
For any state $\mathsf{input} = \mathsf{state}([], t, p, bl, e, h)$
and any continuing candidate $c \in h$, if $t(c) \geq qu$ 
($c$ has reached quota) and $\mathsf{length}(e) < st$ (there are
vacancies), there exists a post-state $\mathsf{output}$ such
that 
$\mathsf{input} ~R~ \mathsf{output}$.
\item[\it reducibility:]
for any states $\mathsf{input}$ and $\mathsf{output}$, if
$\mathsf{input} \mathrel{R} \mathsf{output}$, then $\mathsf{input}$
is of the form 
%$\mathsf{input} =$
$\mathsf{state}([],  t, p, bl, e, h)$, 
$\mathsf{output}$ is of the form 
%$\mathsf{output} =$
$\mathsf{state} ([], nt, np, nbl, ne, nh)$ 
and 
$\mathsf{length}(nh) < \mathsf{length}(h)$
and
$\mathsf{length}(ne) > \mathsf{length}(e)$.
\end{description}
\end{definition}
\noindent
Analogous to Theorem \ref{trans:red} we have the following:
\begin{theorem}\label{elect:red}
If a transition rule $R$ meets the reducibility condition of
Definition~\ref{elect:check},  
then any application of the transition $R$ reduces the complexity measure.
\end{theorem}

\noindent
Similarly we define sanity checks corresponding to other transition
labels, namely 
\textbf{start}, \textbf{count}, \textbf{eliminate},
\textbf{hopeful-win}, and \textbf{elected-win}. 
For all such sanity checks, we establish analogues of 
Theorems~\ref{trans:red} and \ref{elect:red}. Then by drawing on them, we obtain
a corollary on the measure reduction for the generic STV machine.
\begin{corollary}\label{measure:reduction}
Any transition $R$ corresponding to a machine transition in
$\mathcal{T}$ that satisfies the corresponding sanity check reduces the complexity measure.
\end{corollary}  


%\begin{itemize}
%  \item for each transition label $t \in T$, a rule $R_t
%\end{itemize}
%of the generic STV machineThen by the
%generic STV model of computation we mean the structure
%$<\mathcal{S}$, $\mathcal{T}>$, where each transition in
%$\mathcal{T}$ satisfies the pertinent sanity check in
%$\mathcal{SC}$.  \end{definition}

\subsection{The Generic STV Machine} 
The sanity checks constrain the computation that may happen on a
given input state if the corresponding rule is applied. A set of
rules, each of which satisfies the correspoinding sanity check, can
therefore be seen as a small-step semantics for STV counting. We
capture this mathematically as a generic machine.

\begin{definition}[The generic STV machine]
Let $\mathcal{S}$ 
and
$\mathcal{T}$
be the sets of STV states (Definition~\ref{stv:states})
and  
%be the set of
transition labels (Definition~\ref{stv:trans}), respectively. 
The \emph{generic
STV machine} is $M = \langle \mathcal{T}, (S_t)_{t \in \mathcal{T}}
\rangle$ where $S_t$ is the santity check condition 
% associated with
for 
transition $t \in \mathcal{T}$. 
An \emph{instance} of 
$M$
% the generic machine 
is a tuple $I = \langle \mathcal{T}, (R_t)_{t \in
\mathcal{T}} \rangle$, where for each $t \in \mathcal{T}$, $R_t
\subseteq \mathcal{S} \times \mathcal{S}$ is a rule that satisfies
the sanity check condition $S_t$. 
\end{definition}

% \begin{definition}[The generic STV machine]
% Let $\mathcal{S}$ be the set of STV states
% (Definition~\ref{stv:states})  and $\mathcal{T}$ be the set of
% transition labels (Definition~\ref{stv:trans}). The \emph{generic
% STV machine} is $M = \langle \mathcal{T}, (S_t)_{t \in \mathcal{T}}
% \rangle$ where $S_t$ is the santity check condition associated with
% transition $t \in \mathcal{T}$. An \emph{instance} of the generic
% STV machine is a tuple $I = \langle \mathcal{T}, (R_t)_{t \in
% \mathcal{T}} \rangle$, where for each $t \in \mathcal{T}$, $R_t
% \subseteq \mathcal{S} \times \mathcal{S}$ is a rule that satisfies
% the sanity check condition $S_t$. 
% \end{definition}

\noindent
In the sequel, we show that each instance of the generic STV machine
in fact produces an election result, present a formalisation, and
several concrete instances.

\subsection{Progress via the  Applicability Conditions}
  
%subsectionTermination via App
%So far we demonstrated that STV algorithms have three properties in common. They all have states of the computation with similar data structure. Also the steps' names are invariably the same across STV schemes. More importantly the conditions according to which those steps individually take place share universal properties. 

One specific ``sanity check'', in fact the one that 
inspired the very term, is the ability to always 
%be able to
``progress'' the count. That is, one rule is
applicable at every state, so that the count will always progress,
and there are no ``dead ends'', i.e. states of the count that are
not final but to which no rule is applicable. 
As an example, no rule other than count may apply if
there are uncounted ballots (and indeed count must be applicable in
this situation), or that all elected candidates shall be
declared winners if the number of candidates marked elected equals
the number of seats to be filled.  
The key insight is
that if the sanity check conditions (and hence the applicability
conditions) are satisfied, we can always
progress the count by applying a rule. In a nutshell, the following
steps are repeated in order:
\begin{itemize}
  \item the start rule applies (only) at initial states;
  \item cease scrutiny if all vacancies are filled by elected candidates ;
  \item cease scrutiny if all vacancies are filled by elected and continuing candidates;
  \item uncounted ballots shall be counted;
  \item candidates that reach or exceed the quota shall be elected;
  \item the surplus of elected candidates shall be transferred;
  \item the ballots of eliminated candidates shall be transferred;
  \item the weakest candidate shall be eliminated.
\end{itemize}

%
%\begin{definition}\label{stv:alg}
%Suppose the current state of computation is \textsf{input}. Then the following pseudo algorithm specifies which transition should be used.\\
%%\begin{enumerate}
%1. Is \textsf{input} an initial state or an intermediate one? \\
%\hspace*{0.5cm}$\bullet$ if \textsf{input} is an initial state  then apply the rule start \\
%\hspace*{0.5cm}$\bullet$ if \textsf{input} is an intermediate \textsf{state}($ba$,$t$,$p$,$bl$,$e$,$h$), then \\
%\hspace*{0.6cm} 2. Is all vacancies filled, i.e. \textsf{length}($e$) $=$ $st$ ?\\
%\hspace*{0.8cm}
%$\bullet$ if yes then apply elected win and declare winners
%\\\hspace*{0.8cm}
%$\bullet$ if not then \\
%\hspace*{0.95cm} 3. Is \textsf{length} ($e$)$+$ \textsf{length}($h$) less than or equal to $st$?\\ 
%\hspace*{1.1cm}
%$\bullet$ if yes then apply hopeful win and declare winners  
%\\\hspace*{1.1cm} $\bullet$ if not then,\\
%\hspace*{1.3cm} 4. Is there uncounted ballots, i.e. $ba\neq []$ ?\\
%\hspace*{1.5cm} $\bullet$ if yes then apply count transition\\
%\hspace*{1.5cm} $\bullet$ if not then,\\
%\hspace*{1.7cm} 5. Has any candidate reached or exceeded the quota?\\
%\hspace*{1.9cm} $\bullet$ if yes then elect them by elect transition\\
%\hspace*{1.9cm} $\bullet$ if not then,\\
%\hspace*{2.1cm} 6. Are there votes awaiting transfer, i.e. \textsf{fst} $bl\neq []$?\\
%\hspace*{2.3cm} $\bullet$ if yes then,\\
% \hspace*{2.5cm}$\star$ if \textsf{snd} $bl=[]$, then apply transfer-elected\\
% \hspace*{2.5cm}$\star$ if \textsf{snd} $bl\neq []$ then apply transfer-removed\\
%\hspace*{2.3cm} $\bullet$ if not then, eliminate the weakest candidate.\\
%
%\end{definition}
 \noindent
 We realise this order of rule applications in the
 proof of the rule applicability theorem.  We draw upon the local
 rule applicability property, present in the sanity checks
 satisfied by the generic STV model, to guide the theorem prover Coq
 to the proof, according to the pseudo-algorithm above.
 Hence we formally verify the expectation of STV protocols on the
 invariant order of transition applications.
%Moreover, we employ purely constrictive reasoning inside the
%constructive environment of Coq, our proof of the
%theorem~\ref{app}, in particular,  carries computational content.
%This content is used for the purpose of provably correct
%computations in each of the executions of programs extracted from
%Coq into Haskell.
\begin{theorem}[Rule Applicability]\label{app}
Let $I = \langle \mathcal{T}, (R_t)_{t \in \mathcal{T}} \rangle$ be
an instance of the generic STV machine.  For every
non-final state \textsf{input} ,
%of the STV model of computation, 
there is a 
transition label $t \in \mathcal{T}$ and 
a new state \textsf{output} such that 
$\mathsf{input}\mathrel{R_t}\mathsf{output}$.
\end{theorem}

% \begin{theorem}[Rule Applicability]\label{app}
% Let $I = \langle \mathcal{T}, (R_t)_{t \in \mathcal{T}} \rangle$ be
% an instance of the generic STV machine.  If \textsf{input} is a
% non-final state of the STV model of computation, then there is a 
% transition label  $t \in \mathcal{T}$ such that we can
% move from \textsf{input} to a new state \textsf{output} via
% $R_t$, i.e. $\mathsf{input}\mathrel{R_t}\mathsf{output}$.
% \end{theorem}

\noindent
Corollary~\ref{measure:reduction} shows that every applicable transition
$R_t$, for $t \in \mathcal{T}$, 
reduces the complexity measure. 
Theorem~\ref{app} shows that for any non-final machine state,  a
transition from the set $\mathcal{T}$ is applicable. Jointly, they
give a termination property that, in
the terminology of programming semantics, asserts that every execution of the generic STV model has a meaning which is the sequence of computations taken to eventually terminate, and that each execution produces an output which is the value of that execution. 

\begin{theorem}[Termination]\label{termination}
Each execution of every instance of the generic STV machine on any
initial state
\textsf{input} terminates at a final state \textsf{output},
and constructs the sequence of computations taken from
\textsf{input} to reach to \textsf{output}.  
\end{theorem}   

% \begin{theorem}[Termination]\label{termination}
% Each execution of every instance of the generic STV machine on any
% initial state
% \textsf{input} terminates at a final state \textsf{output},
% along with constructing the sequence of computations taken from
% \textsf{input} to reach to \textsf{output}.  
% \end{theorem}   

\section{Formalisation of The Generic Machine in Coq}
We have formalised each notion introduced in the previous section in
the theorem prover Coq. Our formalisation consists of a base layer,
with instances defined in separate modules.
The base layer contains the generic
inductive types, definitions of sanity checks, parametric transition
labels, specification of the STV machine, functions which are used
to formulate the generic STV machine, and theorems proved about the
generic STV model. It also includes functions which are commonly
called by the modules to carry computation for instances of STV.
Instances consist of four parts:

\begin{itemize}
\item[1.] instantiations of the generic counting conditions defined in the base, with concrete instances of counting rules of a particular STV schemes
\item[2.] proofs which establish sanity checks for the instantiated transition rules
\item[3.] possibly auxilary fuctions specific to the particular
instance of STV
\item[4.] an instantiation of the termination theorem which allows
us to synthesise a provably correct, and certifiable, vote counting
implementation
\end{itemize}       
We now  briefly discuss the framework base and explain some design
decisions. In the next section, we give  modular formalisations of three STV algorithms.  

We encode machine states as an inductive type (Figure~\ref{fig;fig.1})
with three constructors: {\fontfamily{qcr}\selectfont initial},
{\fontfamily{qcr}\selectfont state}, and {\fontfamily{qcr}\selectfont
  final}. The constructor {\fontfamily{qcr}\selectfont state} has six
value fields which parametrise the list of uncounted ballots, a list
of tallies, a pile function, and lists of backlogs, elected and continuing candidates, respectively.\\
%\begin{center}
\begin{scriptsize}
\begin{figure}[t]
{\fontfamily{qcr}\selectfont
Inductive STV\_States :=\\
   \hspace*{0.33cm} | initial:
     list ballot -> STV\_States \\
  \hspace*{0.5cm}| state:                                   
\hspace*{0.1cm}  list ballot     \\                   
     \hspace*{2.0cm}$*$ list (cand -> Q)     \\           
     \hspace*{2.0cm}$*$ (cand -> list (list ballot)) \\        
     \hspace*{2.0cm}$*$ (list cand) $*$ (list cand)               \\      
     \hspace*{2.0cm}$*$ \{elected: list cand | length  elected <= st\} \\  
     \hspace*{2.0cm}$*$ \{hopeful: list cand | NoDup hopeful\}         
     -> STV\_States\\
  \hspace*{0.5cm}| winners:                 
    list cand -> STV\_States.       
}
\caption{inductive definition of STV machine states}
\label{fig;fig.1}
\end{figure}
\end{scriptsize}
%\end{center}
\textbf{\emph{Tie breaking.}} To formalise some tie breaking methods
used in some STV schemes, we encode tallies into a chronological list so
we can trace the number of votes which each
candidate received in previous rounds. This allows us to realise one popular tie
breaking procedure. In this method, whenever two or more
candidates have the least votes, we go backwards stepwise, if need be,
to previous states of the machine which we have computed in the same
execution, until we reach a state where one candidate has less votes
than the tied candidates. Then we update the current state of the counting by eliminating this candidate.   


\textbf{\emph{Last parcel.}} Some STV schemes, such as lower house ACT
and Tasmania STV, employ a notion called last parcel, and transfer
only ballots included in this parcel according to next
preferences. Moreover, they compute the fractional transfer value
based on the length of the last parcel. In short, the last parcel of a
candidate is the set of votes they received which made them reach or
exceed the quota to become elected. As a result, we choose to
formalise the pile function to assign a list of lists of ballots to
every candidate: the element of this list are the ballots that have
been counted in favour of the candidate at the successive counts.
This allows us to identify precisely the set of ballots that
comprise the last parcel of any elected candidate. Consequently, we
are able to tailor both the generic transfer and elect rule and
instantiations of them in such a way to modularly formalise several
STV schemes where last parcel is being used.


\textbf{\emph{Parameters.}} 
We formalise the notions of candidates, the quota, and transition
labels parametrically. The parameters are later specified in the
modules for each particular STV. For example, each transition label
is associated with a relation, that is, a function of type {\fontfamily{qcr}\selectfont STV\_States -> STV\_States -> Prop}.  
\paragraph{Sanity checks.} 
Corresponding to each generic transition label, there is a formal definition of the sanity checking. 
\begin{scriptsize}
\begin{figure}[b]
{\fontfamily{qcr}\selectfont
 Definition Elect\_Sanity\_Check (R:STV\_States~-> STV\_States-> Prop) :=\\
   1. ($\forall$ \textsf{input} t p bl e h, \textsf{input} = \textsf{state}([],t,p,bl,e,h) ->\\
    \hspace*{0.3cm} $\exists$ (c: cand),\\
    \hspace*{0.5cm} \textsf{length} (proj1\_sig e) $+ 1$  $\leq$ st \\
   \hspace*{0.5cm} $\wedge$ In c (proj1\_sig h) $\wedge$ (quota $\leq$ (hd nty t) c) -> \\
   \hspace*{1cm} $\exists$ \textsf{output}, R \textsf{input} \textsf{output}) $\wedge$\\
  2. ($\forall$ \textsf{input} \textsf{output}, R \textsf{input} \textsf{output} -> $\exists$ t p np bl nbl e ne h nh,\\
   \hspace*{0.3cm} \textsf{input} = \textsf{state}([],t,p,bl,e,h) \\
   \hspace*{0.45cm}$\wedge$ \textsf{length}(proj1\_sig e) $<$ \textsf{length}(proj1\_sig ne)\\ 
   \hspace*{0.45cm}$\wedge$ \textsf{length}(proj1\_sig nh) $<$ \textsf{length}(proj1\_sig h) \\
  \hspace*{0.5cm}$\wedge$ \textsf{output} = \textsf{state}([],t,np,nbl,ne,nh))
           
}
\caption{Sanity check for elect transition}
\label{fig;fig.2}
\end{figure}
\end{scriptsize}
Sanity checks are constraints which are expected of every instance
of STV to successfully pass in order to be classified as an STV
scheme. Here we illustrate the encoding of the sanity checks for the
elect transition. Items (1) and (2) in the Figure~\ref{fig;fig.2}
respectively match with the first and the second items given in
Definition~\ref{elect:check}. Note that the check loosens the
constraint so that in order for elect rule to apply, we need an
electable continuing candidate and electing them would not exceed
the number of vacancies. This allows us to define a concrete
elect transition for e.g. CADE STV \cite{Beckert:2013:AVC} which elects only one candidate who has reached or exceeded the quota, rather than electing all of the electable candidates together. Moreover, we are able to formalise other instances of elect transitions which do elect all of the eligible candidates in one step. 


\paragraph{Generic STV record.} We bundle the generic quota,  transition labels and the evidence that the generic transitions satisfy the sanity checks in one record type named {\fontfamily{qcr}\selectfont STV\_record}. For example, one field of {\fontfamily{qcr}\selectfont STV\_record} is the requirement that the generic elect transition meets the constraints of the elect sanity check, which technically means ({\fontfamily{qcr}\selectfont Elect\_sanity\_check (elect)}) $\in$ {\fontfamily{qcr}\selectfont STV\_record}. 


Finally, we formally prove all of the mathematical properties discussed under the previous section for any {\fontfamily{qcr}\selectfont stv} of type {\fontfamily{qcr}\selectfont STV\_record}. In particular, we demonstrate the termination property. The termination theorem is instantiated in separate modules with particular {\fontfamily{qcr}\selectfont STV\_record} values, such as ACT STV and CADE STV, to obtain termination property for them as well and carry provably correct computations upon programme extraction into Haskell.
\section{Modular Formalisation of Some STV Systems}
We already have discussed some points where STV schemes diverge from one another. They mainly vary in their specification of formal votes, quota, what is the surplus of an elected candidate, how many candidates to elect out of all of those who are electable, how to update the transfer value of votes of an elected candidate, how to transfer the surpluses, or how to eliminate a candidate and then distribute their votes among other continuing candidates.
%
We describe two of the real-world STV schemes we have formalised. 
  
\subsection{Victoria STV}
The Australian state of Victoria employs a version of
STV~\cite{PV:2002:EA} for  electing upper house representatives. 
%There are some particularities about this STV, all of which we have realised in our work, but our demonstrative intentions only need to elaborate on a few properties related to electing and transferring elected surpluses.
%\begin{enumerate}
%\item[a.] The transfer value of ballots of an elected candidate $c$ is computed by multiplying the current value of each ballot at a fraction according to the following formula  
%\begin{small}
%\begin{tabular}{c}
%surplus votes of $c$\\
%\hline
%(the number of first preference votes received by $c$ )
%\end{tabular}
%\end{small}
%\item[b.] grouping ballots of an eliminated candidate based on their fractional value and then transferring them group by group in order of the magnitude of the value.  
%\item[c.] transferring all surplus votes of an elected candidate in one step. And transferring the surplus of other elected candidates, in order of the magnitude of their tally amount,  in later separate steps.
%\item[d.] candidates may be elected after any of the transfers, if they come to reach or exceed the quota. 
%\end{enumerate}
Figure~\ref{fig;fig.3} depicts the instantiation of the generic
\textbf{elect} transition label with our formulation of the Victoria
STV elect rule. Each line 
%of {\fontfamily{qcr}\selectfont Victoria\_Elect} 
encodes some clauses of the Victorian STV protocol
which specify the elect rule.  We only explain lines 5, 6, and 7 of
Figure~\ref{fig;fig.3}.
%to show how they accommodate some of the protocol's clauses.

\begin{scriptsize}
\begin{figure}[b]
{\fontfamily{qcr}\selectfont
 Definition Victoria\_Elect \textsf{input} \textsf{output} : Prop :=\\ $\exists$ t p np bl nbl nh h e ne, \\
     1. \textsf{input} = \textsf{state}([],t,p,bl,e,h) $\wedge$\\
     2. $\exists$ l, \textsf{length} (proj1\_sig e) $+$ \textsf{length}(l)  $\leq$ st \\
  3. $\wedge$ $\forall$ c, In c l ->(In c (proj1\_sig h) $\wedge$(quota $\leq$ \textsf{hd} nty t (c)))\\
 4.   $\wedge$ \textsf{ordered} (\textsf{hd} nty t) l$\wedge$ \textsf{Permutation} l(proj1\_sig nh)(proj1\_sig h) \\
 5. $\wedge$ \textsf{Permutation} l(proj1\_sig e)(proj1\_sig ne)$\wedge$ (nbl= bl $++$ l)\\
 6. $\wedge$ $\forall$ c, In c l -> (np (c) = \textsf{map}(\textsf{map} (\textsf{fun} b $\Rightarrow$\\ 
 7. (\textsf{fst} b, (\textsf{snd} b)$\times$ ((\textsf{hd} nty t (c))-quota)/((\textsf{hd} [] t)c))(p c)\\
 8. $\wedge$ \textsf{output} = \textsf{state}([],t,np,nbl,ne,nh)
}
\caption{Victoria STV elect transition}
\label{fig;fig.3}
\end{figure}
\end{scriptsize}

The counting protocol of Victoria STV, defines surpuls votes to be \lq\lq \emph{the number, if any, of votes in excess of the
quota of each elected candidate}\rq\rq. Moreover it dictates, under Section 17, Subsection 7 Clause (a), that \lq\lq  \emph{the number of surplus votes of the elected candidate is to be
divided by the number of first preference votes received by the
elected candidate and the resulting fraction is the transfer value}\rq\rq. In lines 6 and 7, we compute the surplus vote and the fractional transfer value accordingly and multiply it by the current value of every ballot in the pile of the elected candidate $c$ to update the pile of this candidate. 


The protocol further states under subsection (8), and (13) that \lq\lq \emph{Any continuing candidate who has received a number of votes equal to
or greater than the quota on the completion of any transfer under subsection (7), or on the completion of a transfer of votes of an
excluded candidate under subsection (12) or (16), is to be declared elected}\rq\rq. 
The definition requires electing candidate(s) no matter how they
have obtained enough votes. We therefore implement clauses (8) and
(13) in Line 5, where we elect everyone over or equal to the quota,
place them in the update list {\fontfamily{qcr}\selectfont ne} of
elected candidates, 
and insist that the list {\fontfamily{qcr}\selectfont l}  of elected
candidates in this state and 
the old list {\fontfamily{qcr}\selectfont e} of elected candidates together form a
permutation of {\fontfamily{qcr}\selectfont ne}. Insisting that the
new (combined) lists of winners are a permutation of
{\fontfamily{qcr}\selectfont l} and {\fontfamily{qcr}\selectfont e}
combined also imply that no new candidates are introduced, or
candidates are duplicated. 

Next, we describe how the updated pile of an elected candidate in {\fontfamily{qcr}\selectfont Victoria\_Elect} is transferred by Victoria's transfer-elect transition.       
Figure~\ref{fig;fig.4} illustrates the instantiation of the generic
transfer-elected rule with a concrete case used by Victoria STV.
Notice that in the first conjunct of Line 4 in
Figure~\ref{fig;fig.3}, we order the list of elected candidates
according to the tally amount. When it comes to transferring elected
surplus, as we see in Line 4 of Figure~\ref{fig;fig.4}, the biggest
surplus is dealt with first which belongs to candidate $c$.
Furthermore, Line 5 specifies that  \emph{all of this candidate's
surplus is distributed} at the fractional value computed in
{\fontfamily{qcr}\selectfont Victoria\_Elect}.
\begin{scriptsize}
%\begin{figure}[h]
\begin{figure}[t]
{\fontfamily{qcr}\selectfont
 Definition Victoria\_TransferElected \textsf{input} \textsf{output} :=\\ $\exists$ nba t p np bl nbl h e, \\
     1. \textsf{input} = \textsf{state}([],t,p,bl,e,h) $\wedge$\\
     2. \textsf{length}(proj1\_sig e) $<$ st $\wedge$
     \textsf{output} = \textsf{state}([],t,np,nbl,ne,nh)\\
     3. $\wedge$ $\forall$ c, In c (proj1\_sig h) -> ((\textsf{hd} nty t) c < quota)\\
 4. $\wedge$ $\exists$ l c, (bl= (c::l,[]) $\wedge$ (nbl= (l,[])) $\wedge$ (np(c) = []) \\
 5. $\wedge$ (nba= \textsf{flat}(fun x => x)(p c) $\wedge$ ($\forall$ d, d$\neq$c -> (np c)=(p d))\\  
}
\caption{Victoria STV transfer-elected transition}
\label{fig;fig.4}
\end{figure}
\end{scriptsize}
%Lines 1 and 3 along with first conjuncts of lines~2 and 4 correspond to the first item of definition~\ref{trans:check} of transfer sanity check. On the other hand, line 5 and conjuncts of line 4 enable {\fontfamily{qcr}\selectfont Victoria\_TransferElected} to successfully pass expectations of the second item in definition~\ref{trans:check}. Hence, the Victoria's instantiation of transfer-elected fulfils the reducibility and local applicability checks of definition~\ref{stv:alg}  and therefore respects the generic STV algorithm.  
%\vspace*{-0.5cm}
\subsection{Australian Capital Territory STV}
Lower house elections in the Australian Capital Territory (ACT) use a version of
STV~\cite{ALA:1994:AEP} which stands out for
some of its characteristics, including transfer of the ``last parcel''
of votes and the formulation of transfer value.  The 
specification of the elect transition of ACT STV is similar to the
one in Figure~\ref{fig;fig.4} except for lines 6 and 7, which are
replaced by the following:\\
\begin{small}
{\fontfamily{qcr}\selectfont np(c)= \textsf{map}}
({\fontfamily{qcr}\selectfont \textsf{fun} b =>}
\begin{tabular}{c}
{\fontfamily{qcr}\selectfont (\textsf{fst} b,(\textsf{snd} b)$\times$((\textsf{hd} nty t(c))- quota)}\\
\hline 
{\fontfamily{qcr}\selectfont (\textsf{Sum} \textsf{snd}(\textsf{last}(p c))}
\end{tabular}) {\fontfamily{qcr}\selectfont (\textsf{last}(p c))}
\end{small}

% replaced by the following.\\ 
% \begin{small}
% {\fontfamily{qcr}\selectfont np(c)= \textsf{map}}
% ({\fontfamily{qcr}\selectfont \textsf{fun} b =>}
% \begin{tabular}{c}
% {\fontfamily{qcr}\selectfont (\textsf{fst} b,(\textsf{snd} b)$\times$((\textsf{hd} nty t(c))- quota)}\\
% \hline 
% {\fontfamily{qcr}\selectfont (\textsf{Sum} \textsf{snd}(\textsf{last}(p c))}
% \end{tabular}) {\fontfamily{qcr}\selectfont (\textsf{last}(p c))}
% \end{small}

\noindent
Moreover, the ACT version of transfer-elected is as in 
Figure~\ref{fig;fig.4} except that the fist conjunct in Line 5 is
replaced and reads \texttt{nba = last
(p c)}. 
The two variations together tell us that we only transfer the last parcel of the elected candidate and the transfer value equals the surplus votes of this candidate divided by the sum of fractional values of this last parcel, rather than the tally of the elected candidate.  

There are obvious issues with the transfer value
formula used in the ACT STV~\cite{DBLP:conf/voteid/GoreL16}. 
For example, it is possible for the calculated fractional
value of a surplus vote to exceed 1, which is clearly a
flaw of the algorithm. As a result, the software used by 
the ACT election commission which implements the
algorithm~\cite{Improvements:2015:EVC}, makes explicit modifications to ensure no surplus votes exceeds 1. We adapt this corrected version in our formalisation. Nonetheless, nothing would restrict  us from  selecting the defective original formula of ACT STV, if we chose to.
%\subsection{CADE STV}
\section{Certifying Extracted Programs and Experiments}

\begin{small}
\begin{figure}[b]
\begin{tabular}{c@{\hspace{2cm}}c}
%\\[0.5em]
    \AxiomC{\scriptsize\textsf{initial} [([a,c,b],1/1),([b,c,a],1/1),([c,a],1/1),([c,b,a],1/1)] }
    %\dashedLine     
        \RightLabel{\tiny start}
    \UnaryInfC{\tiny\textsf{state} [([a,c,b],1/1),([b,c,a],1/1),([c,a],1/1),([c,b,a],1/1)]; a[0/1] b[0/1] c[0/1]; a[] b[] c[]; ([],[]); []; [a,b,c]}
    %\dashedLine    
    \RightLabel{\tiny count}
    \UnaryInfC{\tiny\textsf{state} []; a[1/1] b[1/1] c[2/1]; a[[([a,c,b],1/1)]] b[[([b,c,a],1/1)]] c[[([c,a],1/1),([c,b,a],1/1)]]; ([],[]); []; [a,b,c]}
     %\dashedLine    
    \RightLabel{\tiny eliminate}
    \UnaryInfC{\tiny\textsf{state} []; a[1/1] b[1/1] C[2/1]; a[[(a,c,b],1/1)]] b[[([b,c,a],1/1)]] c[[([c,a],1/1),([c,b,a],1/1)]]; ([],[a]); []; [b,c]}
    %\dashedLine    
    \RightLabel{\tiny transfer-removed}
    \UnaryInfC{\tiny\textsf{state} [([a,c,b],1/1)]; a[1/1] b[1/1] c[2/1]; a[] b[[([b,c,a],1/1)]] c[[([c,a],1/1),([c,b,a],1/1)]]; ([],[a]); []; [b,c]}
    %\dashedLine    
    \RightLabel{\tiny count}
    \UnaryInfC{\tiny\textsf{state} []; a[1/1] B[1/1] c[3/1], a[] b[[([b,c,a],1/1)]] c[[(a,c,b],0/1)]]; ([c],[a]); [c]; [b]}   
    \RightLabel{\tiny elect win} 
    \UnaryInfC{\scriptsize\textsf{winners} [c] }
    \DisplayProof
\end{tabular}
\caption{Example of a certificate}
\label{fig;figure5}
\end{figure}
\end{small}

We use the built-in mechanisms of Coq to  extract executable Haskell
programs for each module. The automatic extraction  method provides
very high assurance that the executable behaves in
accordance to its Coq formalisation.
Correctness proofs established in the Coq therefore give functional
correctness of the 
executables. 
However, each execution of the extracted program generates a
run-time certificate, providing independently checkable evidence
of the underlying computation.


\noindent
Theorem~\ref{termination} guarantees each run of the program
produces \emph{formal} certificate, i.e. a sequence of states of the
count that are linked by rules, as an element of an inductive data
type. (This contrasts with what one may call an \emph{concrete}
certificate which would be a file that comprises a textual
representation of the formal certificate.)
Moreover, the theorem
guarantees that the formal certificate is the sequence of
computation  performed in the execution to obtain the final result. To
produce a concrete certificate from an execution of extracted
Haskell programme, we need to agree on textual representations for
the elements of the data types concerned. 

The certificate generated for each input witnesses 
the correctness of the
count. Note that it is trivial to demonstrate that the existence of
a correct certificate implies the correctness of the result, as the
latter is defined precisely as being obtained through a sequence of
correct rule applications. 
Certificate correctness can be checked by anyone, without \emph{any}
trust in the means that were used in the production of the
certificate, or the underlying hardware. 
%It can be \emph{scrutinised by anyone} for its conformity with the STV counting algorithm employed to tally election votes. 
The fact that concrete certificates can be checked by scrutineers
means that 
our tallying technique satisfies the
count-as-recorded property of universal verifiability. Thus any
election protocol designed for STV schemes which requires a proof of tallying correctness can utilize our tool.

 Figure~\ref{fig;figure5} illustrates an example of a concrete
 certificate, where candidates a, b, and c are competing for one
 seat. We discuss certification only briefly as it is described elsewhere~\cite{Ghale:2017:FVS}.
 We use exact fractions for
 computations to avoid the rounding issues explained
 in~\cite{DBLP:conf/voteid/GoreL16}.
 Every line shows six components, each 
 corresponding to an abstract data representation of the intermediate
 states of the abstract  machine: the 
 list of uncounted ballots; the tallies of candidates; each
 candidate's pile; the backlog; and the lists of elected and
 continuing candidates. 
 %The list of initial ballots is placed at the top. The step start
 %decides on formal ballots and the quota of this sample election.
 %Then we count the first preferences. the candidate a and b receive
 %one vote each and c obtains two. No one is over the quota, so we
 %eliminate the weakest candidate by removing him from the list of
 %continuing candidates and placing him in the second component of
 %backlog. Next step, we transfer his votes by putting them into the
 %list of uncounted ballots. Afterwards, count applies. Since c
 %reached the quota, he is elected. As there was only one vacancy
 %and we have filled it, the rule elect win applies to declare the
 %final result.
 
 
 We have evaluated the efficiency of our approach by testing the
 extracted module for the lower house ACT STV on some real elections
 held in 2008
 and 2012 (Figure~\ref{ref;figure6}). The Molonglo
 electorate of ACT is the biggest lower house electorate in
 Australia, both in the number of vacancies and the number of voters. The extracted
 program computes the result in just 22 minutes.  \begin{small}
\begin{figure}[h]
\centering
%\begin{tabu} to 0.86\textwidth {X[c] X[c] X[c] X[c] X[c] X[c]}
\begin{tabular}{|l |c |c |c |c |c|c|}
\hline
electoral & ballots& vacancies& candidates& time (sec)& certificate size (MB)&year\\
\hline
Brindabella &$63334$&$5$&$19$&$116$&80.6&2008\\
Ginninderra &$60049$&$5$&$27$&$332$&128.9&2008\\
Molonglo &$88266$&$7$&$40$&$1395$&336.1&2008\\
Brindabella&$63562$&$5$&$20$&$205$&94.3&2012\\
Ginninderra&$66076$&$5$&$28$&$289$&126.1&2012\\
Molonglo&$91534$&$7$&$27$&$664$&208.4&2012\\
\hline
\end{tabular}
\caption{ACT Legislative Assembly 2008 and 2012}
\label{ref;figure6}
\end{figure}
\end{small}  
\section{A Technical Discussion}
We have introduced a framework for formalisation, verification, and provably correct computation with various STV algorithms. In the design decisions that we made, 
we have been  balancing different aspects for
designing a framework. The modular design allows for a much simpler implementation than made possibly by other frameworks (e.g.
\cite{Ghale:2017:FVS}) as we only need to discharge proofs at a
per-rule basis which is also reflected in the fact that (a) we capture realistic voting protocols, and (b) we can accommodate a larger number of protocols with ease. 
%\begin{small}
\begin{figure}[b]
%\centering
\begin{scriptsize}
\smallskip\noindent\framebox{\parbox{\textwidth}{
\tikzset{
  treenode/.style = {shape=rectangle, rounded corners,
                     draw, align=center,
                     top color=white, bottom color=blue},
  root/.style     = {treenode, font=\Large, bottom color=white},
  env/.style      = {treenode, font=\ttfamily\normalsize},
  env/.style    = {circle,draw}
}

\begin{tikzpicture}
  [
    grow                    = right,
    sibling distance        = 4.5em,
    level distance          = 12.5em,
    edge from parent/.style = {draw, -latex},
    every node/.style       = {font=\footnotesize},
    sloped
  ]
  \node [root] {\small Parameters}
   % child { node [env] {equation}
    %  edge from parent node [below] {single-line?} }
    child { node [root] {\small Base}
      child { node [env] {\small Instantiation}
        child { node [env] {$STV_k$}
          edge from parent node [below] {\small $k^{th}$ module} }
        child { node [env] {$STV_2$}
          edge from parent node [above] {\small $2^{nd}$ module}
                           node [below] {} }
        child { node [env] {$STV_1$}
                edge from parent node [above] {\small $1^{st}$ module} }
        edge from parent node [below] {} }
      %child { node [env] {multline}
      % edge from parent node [above, align=center]
       %         {first left,\\centered,}
        %      node [below] {last right}}
         %     edge from parent node [above] {multi-line?} 
         };
\end{tikzpicture}
}}
\end{scriptsize}
\caption{System Description}
\label{ref;figure7}
\end{figure}
%\end{small}   

Previous work emphasises data structures and certification, and showcases this by means of monolithic specifications and proofs. Our work adds modularity,  and we distil the algorithmic essence of STV into what we call \emph{sanity checks}.

Every instance of STV satisfying the sanity checks enjoys the rule applicability and termination properties established in Theorems~\ref{app} and~\ref{termination}. Therefore, for an instance of STV to be verified, we simply need to  establish that the sanity checks hold, 
rather than duplicate the whole proof process. These checks
offer an abstraction on the algorithmic side which helps us
avoid duplication of code. Unlike previous work, users do
not need to know how the application  and termination theorems have been proved in order to show termination of their particular instance. Additionally, separation into modules further improves usability. Anyone seeking a verified implementation of their preferred flavour of STV can simply use our framework and instantiate as appropriate. 

Figure~\ref{ref;figure7} illustrates the framework architecture. The parameters component includes type level declaration of candidates, vacancies, and the quota. The base comprises the encoding of the generic STV model along with functions commonly called by the dependent modules. The  instantiation component consists of instantiating types specified in the parameters file and automatically discharging of required proofs. Finally, the instantiated generic model is called into each module for discharging sanity checks and consequently extracting provably correct Hakell programs.
   

The ability to just instantiate is significant as many
aspects are dealt with once and for all
in the base layer of roughly 25000 lines of
code. Each module already formalised is less than 500 lines.
Therefore, an interested user has to just carry out formalisation and discharging sanity checks in about 500 lines to acquire a verified executable implementation of their favourite STV. On the other hand, accomplishing the same goal by using the previous platform, demands  25000 lines of encoding, along with overcoming numerous technicalities.   

\paragraph{\textbf{Related work.}}
DeYoung and Sch\"urmann~\cite{DeYoung:2012:LLV}
formally specify an STV
scheme as a linear logic~\cite{DBLP:journals/apal/Girard93} program
and then discharge the required correctness 
proofs inside the logical framework
Celf~\cite{DBLP:conf/cade/Schack-NielsenS08}. Celf is capable of
executing the specification but their linear logic program does not scale to real-world
elections.

Dawson et.\ al.\ encode an ML program for STV counting into the HOL4
theorem prover~\cite{DBLP:conf/voteid/DawsonGM15} and prove various
correctness properties of the program, including termination. HOL4 is
able to execute the ML encoding within reasonable time bounds for
small elections, but not for large ones. But there is a gap between
the HOL4 semantics of ML and those used by ML compilers. This gap
could be closed by using the proof-producing synthesis~\cite{Myreen} of CakeML code from the HOL assertions, then using the verified CakeML compiler~\cite{POPL14} to porduce the machine code. However, this
has not been done to date. 

Pattinson and Sch\"urmann~\cite{DBLP:conf/ausai/PattinsonS15}, and
Verity and Pattinson~\cite{DBLP:conf/acsw/VerityP17} formalise a
simple version of STV and first-past-the-post elections in Coq and
prove properties such as termination and the existence of winners.
Then they extract certifying executables in Haskell which can handle
real-world elections. Their crucial contribution is that their
executable code produces a certificate for every run, which can be
idependently verified. 

Pattinson and Tiwari~\cite{DBLP:conf/itp/PattinsonT17} extend this
method to tackle the Schultz method.  Their extracted code handles
real-world election and also outputs a certificate for every run.
The certificate not only witnesses how the winner was elected, but also
provides concrete evidence that each losing candidate is a ``loser''.

%\iffalse
%Dawson et al~\cite{DBLP:conf/voteid/DawsonGM15} formalise a version of Hare-Clark in the theorem prover HOL~\cite{hol4}. Their specification is expressed in the Higher-Order-Logic. Moreover, they encode computational definition inside HOL and prove its correctness against the HOL specification of the protocol.  Then to actually compute, they manually transliterate the computational definitions from HOL into the syntax of Standard ML functional language.  A significant issue with\marginpar{This prose is not acceptable to me. I have reworded it above.} this approach is existence of no guarantee that the transliterate encoding would behave according to the original HOL definitions, simply because of semantic differences of HOL and SML. Therefore, their verification does not legitimately extend beyond HOL to the SML programme.\fi
\section{Conclusion}
We have designed a modular framework for formalisation, verification, 
and provably correct computation of STV algorithms. Our work
is fully formalised, provides an encoding and provably correct
executables for various flavours of STV. 
\bibliographystyle{splncs03}
%\bibliography{paper,delta2,ev}

\begin{thebibliography}{10}
\providecommand{\url}[1]{\texttt{#1}}
\providecommand{\urlprefix}{URL }

\bibitem{ALA:1994:AEP}
{ACT Legislative Assembly}: An act to entrench the principles of the
  proportional representation (hare-clark) electoral system (1994)

\bibitem{Beckert:2013:AVC}
Beckert, B., Gor{\'{e}}, R., Sch{\"{u}}rmann, C.: Analysing vote counting
  algorithms via logic - and its application to the {CADE} election scheme. In:
  Bonacina, M.P. (ed.) Proc. CADE 2013. Lecture Notes in Computer Science, vol.
  7898, pp. 135--144. Springer (2013)

\bibitem{Bertot:2004:ITP}
Bertot, Y., Cast{\'e}ran, P., Huet, G., Paulin-Mohring, C.: Interactive theorem
  proving and program development : Coq'Art : the calculus of inductive
  constructions. Texts in Theoretical Computer Science, Springer (2004)

\bibitem{DBLP:journals/iacr/CortierGKMT16}
Cortier, V., Galindo, D., K{\"{u}}sters, R., M{\"{u}}ller, J., Truderung, T.:
  Verifiability notions for e-voting protocols. {IACR} Cryptology ePrint
  Archive  2016,  287 (2016)

\bibitem{DBLP:conf/voteid/DawsonGM15}
Dawson, J.E., Gor{\'{e}}, R., Meumann, T.: Machine-checked reasoning about
  complex voting schemes using higher-order logic. In: Proc. EVote-ID 2015. pp.
  142--158 (2015)

\bibitem{DeYoung:2012:LLV}
DeYoung, H., Sch{\"{u}}rmann, C.: Linear logical voting protocols. In: Kiayias,
  A., Lipmaa, H. (eds.) Proc. VoteID 2011. Lecture Notes in Computer Science,
  vol. 7187, pp. 53--70. Springer (2012)

\bibitem{Droop:1881:MER}
Droop, H.R.: On methods of electing representatives. Journal of the Statistical
  Society of London  44(2),  141--202 (1881)

\bibitem{Ghale:2017:FVS}
Ghale, M.K., Gor{\'{e}}, R., Pattinson, D.: A formally verified single
  transferable voting scheme with fractional values. In: Krimmer, R., Volkamer,
  M., Binder, N.B., Kersting, N., Pereira, O., Sch{\"{u}}rmann, C. (eds.) Proc.
  E-Vote-ID 2017. Lecture Notes in Computer Science, vol. 10615, pp. 163--182.
  Springer (2017)

\bibitem{DBLP:journals/apal/Girard93}
Girard, J.: On the unity of logic. Ann. Pure Appl. Logic  59(3),  201--217
  (1993)

\bibitem{DBLP:conf/voteid/GoreL16}
Gor{\'{e}}, R., Lebedeva, E.: Simulating {STV} hand-counting by computers
  considered harmful: {A.C.T}. In: Proc. EVote-ID 2016. pp. 144--163 (2016)

\bibitem{Trust:2018:AT}
{John Muir Trust}: Apply to be a trustee,
  \url{https://www.johnmuirtrust.org/assets\\/000/002/860/How\_to\_apply\_to\_be\_a\_Trustee\_Jan\_2018\_original.pdf},
accessed May 15, 2018

\bibitem{POPL14}
Kumar, R., Myreen, M.O., Norrish, M., Owens, S.: {CakeML}: A verified
  implementation of {ML}. In: Principles of Programming Languages ({POPL}). ACM
  (Jan 2014)
\bibitem{Myreen}
Magnus, M.O, Scott, O.:
Proof-producing translation of higher-order logic into pure and stateful ML. J. Funct. Program. 24(2-3): 284-315 (2014)
\bibitem{Letouzey:2003:NEC}
Letouzey, P.: A new extraction for {Coq}. In: Geuvers, H., Wiedijk, F. (eds.)
  Proc. TYPES 2002. Lecture Notes in Computer Science, vol. 2646, pp. 200--219.
  Springer (2003)

\bibitem{DBLP:conf/ausai/PattinsonS15}
Pattinson, D., Sch{\"{u}}rmann, C.: Vote counting as mathematical proof. In:
  {AI} 2015: Advances in Artificial Intelligence - 28th Australasian Joint
  Conference. pp. 464--475 (2015)

\bibitem{DBLP:conf/itp/PattinsonT17}
Pattinson, D., Tiwari, M.: Schulze voting as evidence carrying computation. In:
  Proc. ITP 2017. pp. 410--426 (2017)

\bibitem{DBLP:conf/cade/Schack-NielsenS08}
Schack{-}Nielsen, A., Sch{\"{u}}rmann, C.: Celf - {A} logical framework for
  deductive and concurrent systems (system description). In: Proc. IJCAR 2008.
  pp. 320--326 (2008)

\bibitem{Improvements:2015:EVC}
{Software Improvements}: Electronic and voting and counting sytems. http://www.softimp.com.au/evacs/index.html, accessed at May 12, 2015

\bibitem{StackExchange:2018:ME}
StackExchange: Moderator elections (2018),
  \url{https://math.stackexchange.com/\\election/6?tab=election}, accessed May
  15, 2018

\bibitem{PV:2002:EA}
{The Parliament of Victoria}: Electoral act 2002 , see also https://www.elections.act\\.gov.au/education/act\_electoral\_commission\_fact\_sheets/fact\_sheets\_-\_general\_html/elections\_act\_factsheet\_hare-clark\_electoral\_system

\bibitem{DBLP:conf/acsw/VerityP17}
Verity, F., Pattinson, D.: Formally verified invariants of vote counting
  schemes. In: Proc. ACSW 2017. pp. 31:1--31:10 (2017)

\end{thebibliography}
\end{document}
